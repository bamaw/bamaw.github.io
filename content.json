{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"关于我","text":"90后，2017年毕业于 西安交通大学城市学院 电气工程及其自动化，就职于特种设备行业，目前从事人机交互类开发工作 目前在浙江杭州，热爱技术，希望有一天能创造出被人熟知的产品 不满是向上的车轮，能够载着不自满的人前进，凡事总须研究，才会明白 待更新… …","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"test","text":"","link":"/2020/10/13/test/"},{"title":"Go语言初识","text":"前言最近由于公司语音通话后台项目是go语言开发，因为之前在论坛上或者其他技术圈里面听说过此等神物，刚好趁这次机会学习下。目前，go语言已经成为大厂的标配开发语言。go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。 它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言（摘取官网） 核心思想及特性Go语言之所以厉害，是因为它在服务端的开发中，总能抓住程序员的痛点，以最直接、简单、高效、稳定的方式来解决问题。这里我们并不会深入讨论GO语言的具体语法，只会将语言中关键的、对简化编程具有重要意义的方面介绍给大家，体验Go的核心特性。 大道至简,小而蕴真 让事情变得复杂很容易，让事情变得简单才难 深刻的工程文化 Go语言能做什么Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web 应用、API应用、下载应用等；除此之外，Go语言还适用于内存数据库和云平台领域，目前国外很多云平台都是采用Go开发。 服务器编程，以前你如果使用Java/C/C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等 分布式系统、数据库代理器、中间件等，例如Etcd 网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用，而且Go内置的net/http包基本上把我们平常用到的网络功能都实现了 数据库操作 开发云平台，目前国外很多云平台在采用Go开发 Go语言的特色 没有继承多态的面向对象 强一致类型 interface不需要显式声明(Duck Typing) 没有异常处理(Error is value) 基于首字母的可访问特性 不用的import或者变量引起编译错误 完整而卓越的标准库包 Go内置runtime（作用是性能监控、垃圾回收等） 写到最后Go语言作为一门大型项目开发语言，在很多大公司相继使用，甚至完全转向Go开发。这些关键新技术，可以让你拿到技术的先机。这些对一个需要技术领导力的个人或公司来说都是非常重要的。所以，小伙伴们加油！！！","link":"/2020/07/07/golang/1-go%E8%AF%AD%E8%A8%80%E5%88%9D%E8%AF%86/"},{"title":"Go语言环境搭建","text":"官网访问首先我们登录Golang的官方网站：https://golang.org/,如果打不开可以登录国内网站https://golang.google.cn/ 下载在Mac、Windows和Linux三个平台上都支持Golang。可以根据自己的电脑在国内官网https://golang.google.cn/dl/或者是Go语言中文网https://www.studygolang.com/dl下载相应平台的安装包。因为我使用的是Mac本，所以演示Mac安装。 目前最新的版本是Go1.14.4，所以我这边按照最新的版本安装。 下载二进制包：go1.14.4.darwin-amd64.tar.gz 将下载的二进制包解压至 /usr/local目录 1tar -C /usr/local -xzf go1.14.4.darwin-amd64.tar.gz 注意：MAC 系统下你可以使用* **.pkg 结尾的安装包直接双击来完成安装，安装目录在 /usr/local/go/ *下 配置GOROOT和PATH123456789101112// 编辑~/.bash_profile文件bamawdeMacBook-Pro:~ bamaw$ vim ~/.bash_profile//在~/.bash_profile文件中添加以下2条命令export GOROOT=/usr/local/goexport PATH=$PATH:$GOROOT/bin// 保存点击ESC，并输入:wq保存并退出编辑// 配置生效bamawdeMacBook-Pro:~ bamaw$ source ~/.bash_profile 检查是否安装成功版本检测12bamawdeMacBook-Pro:~ bamaw$ go versiongo version go1.14.4 darwin/amd64 配置信息12345678910111213141516171819202122232425262728293031323334bamawdeMacBook-Pro:~ bamaw$ go envGO111MODULE=\"\"GOARCH=\"amd64\"GOBIN=\"\"GOCACHE=\"/Users/bamaw/Library/Caches/go-build\"GOENV=\"/Users/bamaw/Library/Application Support/go/env\"GOEXE=\"\"GOFLAGS=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"darwin\"GOINSECURE=\"\"GONOPROXY=\"\"GONOSUMDB=\"\"GOOS=\"darwin\"GOPATH=\"/Users/bamaw/go\"GOPRIVATE=\"\"GOPROXY=\"https://proxy.golang.org,direct\"GOROOT=\"/usr/local/go\"GOSUMDB=\"sum.golang.org\"GOTMPDIR=\"\"GOTOOLDIR=\"/usr/local/go/pkg/tool/darwin_amd64\"GCCGO=\"gccgo\"AR=\"ar\"CC=\"clang\"CXX=\"clang++\"CGO_ENABLED=\"1\"GOMOD=\"\"CGO_CFLAGS=\"-g -O2\"CGO_CPPFLAGS=\"\"CGO_CXXFLAGS=\"-g -O2\"CGO_FFLAGS=\"-g -O2\"CGO_LDFLAGS=\"-g -O2\"PKG_CONFIG=\"pkg-config\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/sh/14n7qm5x3_7575y_dmwvhc_h0000gn/T/go-build295305736=/tmp/go-build -gno-record-gcc-switches -fno-common\" 解释说明 GOROOT，就是go的安装目录 Gopath就是Go项目代码存放的位置 该目录下有3个子目录：src，pkg，bin GO代码必须在工作空间内。工作空间是一个目录，其中包含三个子目录： src —- 每一个子目录，就是一个包。包内是Go的源码文件 pkg —- 编译后生成的，包的目标文件 bin —- 生成的可执行文件 至此，Go语言开发环境搭建完毕。","link":"/2020/07/08/golang/2-go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"Maven入门介绍","text":"基本介绍Maven是一个项目管理工具，可以对Java项目进行构建、依赖管理。它包含了一个项目对象模型（Project Object Model）,从我们创建的Maven项目中看到，就是一个pom.xml文件。 Maven两大核心思想： 依赖管理：对项目使用的jar包统一管理(Maven提供一个中央仓库https://mvnrepository.com/，当我们在项目中需要哪些依赖的时候，Maven会自动去中央仓库帮我下下载相关的依赖包，并解决包之前存在的依赖的问题) 项目构建：对项目进行编译、测试、打包、部署、运行等 举例：项目A和B，项目A需要依赖某些jar包，项目B也需要依赖这些jar包，如果都把jar包引入到项目中，就是在重复造轮子，我们应该把这些所有的jar包放到一个地方，需要用的时候过去取即可 为什么使用Maven我们在开发项目中，会使用许多工具类，这些工具类都是以jar包的形式出现。通常一个项目所依赖的jar包会很多，这到不是什么大问题，主要是jar包的版本往往是个问题，往往选择一个jar包的版本需要考虑它所依赖的jar包是否支持这个版本，同时还需要确认依赖它的jar包能不能对这个版本兼容。所以，当项目较大的时候，依赖管理变得非常麻烦。Maven的出现，比较好的解决了开发过程中遇到的这个难题。 另外，项目开发过程中，我们可能会对项目进行拆分变成多模块项目。一般来说，针对多模块项目，每一个子模块无法单独执行，需要借助其他模块，才可以正常运行。这个时候，我们就可以借助Maven工具，可以实现项目的打包、发布等工作。 Maven仓库分类及说明 Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。它能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方 本地仓库：本地仓库存储在本地的磁盘当中，里面存放的是经常使用的jar包； 123456&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;localRepository&gt;/Users/bamaw/develop/Java/maven/maven-repo&lt;/localRepository&gt;&lt;/settings&gt; 中央仓库：由 Maven 社区提供的仓库，其中包含了大量常用的库（maven 社区提供了一个 URL：http://search.maven.org/#browse）； 远程仓库：俗称私服。基本每个公司都会有自己的私服，当本地的磁盘中不存在需要的jar包资源，则会请求私服进行资源下载； 1234567891011121314151617181920212223242526&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.companyname.projectgroup&lt;/groupId&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.companyname.common-lib&lt;/groupId&gt; &lt;artifactId&gt;common-lib&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;companyname.lib1&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib1&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;companyname.lib2&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib2&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; Maven依赖搜索顺序 当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库： 步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。 步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。 步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件） Maven 阿里云(Aliyun)仓库 Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。 全局配置 可以添加阿里云的镜像到maven的setting.xml配置中，这样就不需要每次在pom中，添加镜像仓库的配置，在mirrors节点下面添加子节点： 1234567891011121314151617181920&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 单项目配置 单项目配置时，需要修改pom文件。pom文件中，没有mirror元素。在pom文件中，通过覆盖默认的中央仓库的配置，实现中央仓库地址的变更。 修改项目中pom文件： 123456789101112131415&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;!-- 是否开启发布版构件下载 --&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!-- 是否开启快照版构件下载 --&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;","link":"/2020/07/01/maven/1-Maven%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"},{"title":"Maven安装说明","text":"安装前提由于Maven是一个基于java的工具，因此必须先安装JDK(不做阐述)。 检查java环境安装 1java -version 下载Maven 下载地址：https://maven.apache.org/download.cgi 解压并配置由于我之前已经安装过Maven（V3.6.1）,可根据自己的需要下载版本，这里不做要求。 配置环境变量 打开终端，终端输入：vim ~/.bash_profile 我的maven安装路径：/Users/bamaw/develop/Java/maven/apache-maven-3.6.1 123#mavenexport MAVEN_HOME=/Users/bamaw/develop/Java/maven/apache-maven-3.6.1export PATH=$PATH:$MAVEN_HOME/bin 保存文件，并运行如下命令使环境变量生效： 1source ~/.bash_profile 检验安装是否成功打开终端，输入命令，当出现如下图所示，表明安装成功。 1mvn -v 建立maven项目会需要去仓库下载一些相关的依赖包。maven默认的中央仓库是英国，所以我们把中央仓库改为maven阿里云中央仓库 修改maven根目录下的conf文件夹中的setting.xml文件，内容如下： maven安装路径：apache-maven-3.6.1/conf/setting.xml 1234567891011################55行############################# 本地存放的路径&lt;localRepository&gt;/Users/bamaw/develop/Java/maven/maven-repo&lt;/localRepository&gt;################159行############################ 这里使用的是阿里云仓库&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;","link":"/2020/07/01/maven/2-Maven%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/"},{"title":"微服务介绍","text":"基本介绍微服务架构越来越流行，这个没有异议。 2009年，Netflix重新定义了它的应用程序的开发模型，这个算是微服务的首次探索。 2014年，《Mircoservices》通过以一个更加通俗易懂的方式，为大家定义了微服务。 为什么要用微服务？ 互联网应用产品的两大特点： 需求变化快； 用户群体庞大； 在这种情况下，我们需要构建一个能够灵活扩展，同时能够快速应对外部环境变化的一个应用，使用传统的开发模式，显然无法满足需求，这个时候，微服务就登场了。 什么是微服务简单的说，微服务就是一种将单一应用程序拆分成一组小型服务的方法，拆分完成后，每一个服务都可以独立运行在进程中，服务与服务之间采用轻量级的通信机制来进行沟通（SpringCloud中采用基于http的Restful API）。 每一个服务都是围绕具体的业务进行构建，例如，一个电商系统（订单服务、支付服务、物流服务、会员服务等等），这些拆分后的应用都是可以独立运行的，都可以独立部署到生产环境中。也可以这么理解，我们在开发项目中，不再拘泥于一种语言，可以java、python、go、php等等，在一个大的项目中混合使用各种语言，这在传统的应用开发中是无法想象的。而使用微服务之后，我们可以根据业务自身来选择合适的语言和构建工具进行开发。 微服务可以理解为是SOA的传承，两者本质的区别 微服务是一个真正分布式、去中心化的，微服务的拆分比SOA更加彻底。 微服务优势 复杂度可控； 独立部署； 技术选型灵活； 较好的容错性； 较强的可扩展性； 使用Spring Cloud的优势SpringCloud 可以理解为微服务思想在java领域的一个具体落地。SpringCloud在发展之初，就借鉴了微服务的思想，同时结合SpringBoot,SpringCloud提供组件式的一键式启动和部署能力，极大的简化了微服务架构的落地。 SpringCloud这种框架，从设计之初就充分考虑了分布式架构演化所需要的功能，例如：服务注册、配置中心、消息总线以及负载均衡等。这些功能都是以可插拔式的形式提供出来，这样，在分布式系统的不断演化过程中，我们的SpringCloud也可以非常方便的演变。","link":"/2020/09/03/springcloud/1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/"},{"title":"SpringCloud介绍","text":"什么是SpringCloudSpringCloud是一系列框架的集合，SpringCloud内部包含了很多框架，这些框架互相协作，共同来构建分布式系统。利用这些组件，可以非常方便的构建一个分布式系统。 核心特性 服务注册与发现； 负载均衡； 服务之间的调用； 容错、服务降级、断路器； 消息总线； 分布式配置中心； 链路器； 版本名称不同于其他的框架，Spring Cloud 版本名称是通过 A(Angel)、B(Brixton)、C(Camden)、D(Dalston)、E(Edgware)、F(Finchley)。这些名字使用了伦敦地铁站的名 字，目前最新版是 H (Hoxton)版。 SpringCloud中。除了大的版本之外，还有一些小版本，小版本命名方式如下： M ，M 版是 milestone （里程碑）的缩写，所以我们会看到一些版本叫 M1、M2； RC，RC 是 Release Candidate，表示该项目处于候选状态，这是正式发版之前的一个状态，所以 我们会看到 RC1、RC2； SR，SR 是 Service Release ，表示项目正式发布的稳定版，其实相当于 GA(Generally Available) 版。所以，我们会看到 SR1、SR2； SNAPSHOT，这个表示快照版； SpringCloud体系1.包含的组件 Spring Cloud Netflix，这个组件，在 Spring Cloud 成立之初，立下了汗马功劳。但是， 2018 年 的断更，也是 Netflix 掉链子了； Spring Cloud Config，分布式配置中心，利用 Git/Svn 来集中管理项目的配置文件； Spring Cloud Bus，消息总线，可以构建消息驱动的微服务，也可以用来做一些状态管理等； Spring Cloud Consul，服务注册发现； Spring Cloud Stream，基于 Redis、RabbitMQ、Kafka 实现的消息微服务； Spring Cloud OpenFeign，提供 OpenFeign 集成到 Spring Boot 应用中的方式，主要解决微服务 之间的调用问题； Spring Cloud Gateway，Spring Cloud 官方推出的网关服务； Spring Cloud Cloudfoundry，利用 Cloudfoundry 集成我们的应用程序； Spring Cloud Security，在 Zuul 代理中，为 OAuth2 客户端认证提供支持； Spring Cloud AWS ，快速集成亚马逊云服务； Spring Cloud Contract，一个消费者驱动的、面向 Java 的契约框架； Spring Cloud Zookeeper，基于 Apache Zookeeper 的服务注册和发现； Spring Cloud Data Flow，在一个结构化的平台上，组成数据微服务； Spring Cloud Kubernetes，Spring Cloud 提供的针对 Kubernetes 的支持； Spring Cloud Task，短生命周期的微服务； 2.Spring Cloud 和 Spring Boot 版本关系 Spring Cloud Spring Boot Hoxton 2.2.x Greenwich 2.1.x Finchley 2.0.x Edgware 1.5.x Dalston 1.5.x","link":"/2020/09/04/springcloud/2-SpringCloud%E4%BB%8B%E7%BB%8D/"},{"title":"Logback日志无法按天分割问题小记","text":"问题描述线上查看Mqtt消息服务项目时，发现服务器中系统的日志不能按天生成日志文件，全部的日志信息都打印到了启动运行项目的那一天中了且此日志文件越来越大，只有重启项目之后才会生成当天的日志文件。 ####回想当时开发的时候为什么没有发现？ 开发的时候，基本每天都会重启，且日志正常； 部署的时候，打包的时候日志文件夹也会打包进入，当时启动后看了看正常，就所以然了。 分析原因这个Mqtt消息服务项目使用SpringBoot + Logback框架，查看其配置文件，发现 策略组合 使用问题。 以下是当时项目中的有问题的配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration debug=\"false\"&gt; &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt; &lt;property name=\"LOG_HOME\" value=\"./logs\" /&gt; &lt;!--配置CONSOLE控制台文件输出项--&gt; &lt;appender name=\"CONSOLELOG\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS } [%thread] %-5level %logger{50} - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--配置INFO文件输出项--&gt; &lt;appender name=\"DAYINFOLOG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;!--过滤error日志--&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!--配置滚动策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;${LOG_HOME}/info/%d{yyyy-MM-dd}-info.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--日志文件最大的大小--&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!--配置ERROR文件输出项--&gt; &lt;appender name=\"DAYERRORLOG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 比较日志记录请求的Level值和ThresholdFilter中配置的Level值 当日志记录请求的Level值小于ThresholdFilter中配置的Level值，日志记录请求被判定为无效 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;!--配置滚动策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;${LOG_HOME}/error/%d{yyyy-MM-dd}-error.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--日志文件最大的大小--&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!-- 日志输出级别 --&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLELOG\" /&gt; &lt;appender-ref ref=\"DAYINFOLOG\"/&gt; &lt;appender-ref ref=\"DAYERRORLOG\"/&gt; &lt;/root&gt;&lt;/configuration&gt; 配置中使用了基于时间的滚动切割策略 TimeBasedRollingPolicy，每天凌晨0点自动生成新的日志文件。但是可以注意到里面包含了一段 triggeringPolicy触发策略，即最大单个文件超过 10MB 自动新成新日志文件， TimeBasedRollingPolicy 是基于时间的，不能和其他策略一起组合使用。 这个配置文件包含了两个策略： 时间维度； 文件大小维度； 解决方案方案一：去掉组合策略 triggeringPolicy 123456789101112131415161718192021222324 &lt;appender name=\"DAYINFOLOG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;!--过滤error日志--&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!--配置滚动策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;${LOG_HOME}/info/%d{yyyy-MM-dd}-info.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt;// 错误输出日志同理，不再只是展示 方案二：使用时间和大小组合策略 *SizeAndTimeBasedRollingPolicy * 123456789101112131415161718192021&lt;appender name=\"DAYINFOLOG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;!--过滤error日志--&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!--配置滚动策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;${LOG_HOME}/info/%d{yyyy-MM-dd}-info-%i.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; 注意事项1&lt;FileNamePattern&gt;${LOG_HOME}/info/%d{yyyy-MM-dd}-info-%i.log&lt;/FileNamePattern&gt; 注意后面的 %i是必须要加上去的，是单个日志文件超大小后的切割序号,以便我们分析处理。 使用以上两种解决方案都可以解决Logback不能按天切割生成日志文件的问题，","link":"/2020/09/15/log/logback/1-Logback%E6%97%A5%E5%BF%97%E6%97%A0%E6%B3%95%E6%8C%89%E5%A4%A9%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"springcloud","slug":"springcloud","link":"/tags/springcloud/"},{"name":"log","slug":"log","link":"/tags/log/"},{"name":"logback","slug":"logback","link":"/tags/logback/"}],"categories":[{"name":"golang","slug":"golang","link":"/categories/golang/"},{"name":"maven","slug":"maven","link":"/categories/maven/"},{"name":"springcloud","slug":"springcloud","link":"/categories/springcloud/"},{"name":"logback","slug":"logback","link":"/categories/logback/"}]}